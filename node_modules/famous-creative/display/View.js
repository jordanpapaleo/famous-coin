/**
 * View class that extends Modifier and should be used for visual elements.
 */

import Modifier from './Modifier';

const DOMElement = FamousPlatform.domRenderables.DOMElement;
const EventEmitter = FamousPlatform.components.EventEmitter;
const EventHandler = FamousPlatform.components.EventHandler;
const Mesh = FamousPlatform.webglRenderables.Mesh;
const Node = FamousPlatform.core.Node;
const PointLight = FamousPlatform.webglRenderables.PointLight;

const EventMap = [
  // UI Events (http://www.w3.org/TR/uievents/)
  'abort',
  'beforeinput',
  'blur',
  'click',
  'compositionend',
  'compositionstart',
  'compositionupdate',
  'dblclick',
  'focus',
  'focusin',
  'focusout',
  'input',
  'keydown',
  'keyup',
  'load',
  'mousedown',
  'mouseenter',
  'mouseleave',
  'mousemove',
  'mouseout',
  'mouseover',
  'mouseup',
  'resize',
  'scroll',
  'select',
  'touchcancel',
  'touchend',
  'touchmove',
  'touchstart',
  'unload',
  'wheel'
];

export default class View extends Modifier{
  constructor(node, options) {
    super(node);
    this.options = options;
  }

  //HTML STUFF
  validateDOM(options) {
    if (!this.el) {
      this._events = {};
      this.el = new DOMElement(this.node, options);
      this.el.onReceive = (event, payload) => {
        if (this._events[event]) {
          this._events[event](payload);
        }
      };
    }
  }

  createDOMElement(options) {
    this.validateDOM(options);
    return this;
  }

  setDOMContent(content) {
    this.validateDOM();
    this.el.setContent(content);
    return this;
  }

  setDOMClasses(classes) {
    this.validateDOM();
    for (let i = 0; i < classes.length; i++) {
      this.el.addClass(classes[i]);
    }
    return this;
  }
  setDOMAttributes(attributes) {
    this.validateDOM();
    for (let attrName in attributes) {
      this.el.setAttribute(attrName, attributes[attrName]);
    }
    return this;
  }
  setDOMProperties(properties) {
    this.validateDOM();
    for (let propertyName in properties) {
      this.el.setProperty(propertyName, properties[propertyName]);
    }
    return this;
  }

  //dom events
  on(evName, fn) {
    if (EventMap.indexOf(evName) > -1) {
      //dom Event
      this.validateDOM();
      this.node.addUIEvent(evName);
      this._events[evName] = fn;
    } else {
      if (!this.eventHandler) this.eventHandler = new EventHandler(this.node);
      this.eventHandler.on(evName, fn);
    }
    return this;
  }

  //events between views!
  emit(ev, payload) {
    if (!this.eventEmitter) this.eventEmitter = new EventEmitter(this.node);
    this.eventEmitter.emit(ev, payload);
  }

  //gl stuff
  validateMesh() {
    if (!this.mesh) this.mesh = new Mesh(this.node);
  }

  setGeometry(geometry, options) {
    this.validateMesh();
    this.geometry = geometry;
    this.mesh.setGeometry(geometry, options);
    return this;
  }

  setBaseColor(color) {
    this.validateMesh();
    this.mesh.setBaseColor(color);
    return this;
  }
}


